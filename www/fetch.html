<html>
  <head>

    <!-- Node modules styles -->
    <link href="node_modules/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="node_modules/daterangepicker/daterangepicker.css" rel="stylesheet">


    <!-- End node module styles -->

    <script type="text/javascript" src="funcs.js"></script>


    <!-- Javascript -->
    <script type="text/javascript" src="node_modules/vue/dist/vue.js"></script>
    <script type="text/javascript" src="node_modules/jquery/dist/jquery.js"></script>
    <script type="text/javascript" src="node_modules/bootstrap/dist/js/bootstrap.js"></script>
    <script type="text/javascript" src="node_modules/moment/moment.js"></script>
    <script type="text/javascript" src="node_modules/daterangepicker/daterangepicker.js"></script>
    <!-- End Javascript -->


    

    <style>

    .unit-square {
      display: inline-block;
      width: 20px;
      height: 20px;
      background-color: black;
      margin: 5px;
      font-size: 6px;
    }

    .maActive {
      background-color: red;
    }

    </style>

    

  </head>

  <body>

    <div id="app">

      

      <form class="form-inline">

        <div class="form-group">
          <label for='status-type-select'>Status Type</label>
          <select id='status-type-select' name="status" v-model="status">
            <option value="BROKEN">Broken</option>
            <option value="INSPECTION">Inspection</option>
            <option value="REHAB">Rehab</option>
            <option value="OFF">Off</option>
          </select>
        </div>

        <div class="form-group">
          <label for='sort-select'>Sort Order</label>
          <select id='sort-select' name="sortorder" v-model="sortorder">
            <option value="unitid">Unit Id</option>
            <option value="station">Station</option>
            <option value="mostbroken">Most Broken</option>
          </select>
        </div>

        <div class="form-group">
          <label for='date-index-input'>Date Index</label>
          <input id='date-index-input' type="number" min=0 v-model="date_index">
        </div>

        <input id='daterangeinput' type="text" name="daterange" />

        <div class="form-group">
          <label for="tick-input">Sleep</label>
          <input id='tick-inpu' type='number' name='tick' v-model="tick" />
        </div>

        <div class="form-group">
          <input class="btn btn-primary" type="button" value="Play" v-on:click="play()">
          <input class="btn btn-danger" type="button" value="Stop"  v-on:click="stop()">
          <input class="btn btn-warning" type="button" value="Reset"  v-on:click="reset()">
        </div>


      </form>

      <p>Animation State: {{ animation_state }}</p>
      <p>Start Date: {{ start_date }}</p>
      <p>End Date: {{ end_date }}</p>

      {{ items && items.dates[[date_index]] }}

      <div v-if="items !== null">

        <!-- TODO:
        1. Add a key here to track the unit.
        2. Provide styling based on the date.
        -->

        <div
          class="unit-square"
          v-for="(unit, index) in units"
          :key="unit.unit_id"
          v-bind:class="{
            maActive: highlighted_units[unit.unit_index] == 1,
            maNotActive: highlighted_units[unit.unit_index] == 0}"
          :title="unit.unit_id"

          >
          {{ index }}
        </div>
      </div>

    </div>

    <script>

      var apiURL = "unit_by_date.json";

      var app = new Vue({
        el: '#app',
        data: {
          message: 'Hello Vue!',
          items : null,
          units : [],
          status : "BROKEN",
          date_index : 0,
          daterangeinput_el: null,
          min_date: null,
          max_date: null,
          start_date: null,
          end_date: null,

          start_date_index: null,
          end_date_index: null,
          timeout_id: null,
          tick: 300, // 300ms
          animation_state: "STOP",
          last_tick: null,
          sortorder: "unitid"

        },
        watch: {
          sortorder : function() {
            this.sort_units();
          }
        },
        created: function () {
          this.fetchData();
        },

        methods: {

          fetchData: function () {
            var self = this;
            var req = $.getJSON( apiURL, function( new_data ) {
                console.log("Got the data.");
                self.items = new_data;
                self.units = hydrate_units(new_data);
                self.configure_date_range_picker();

                // Sort units by broken count
                self.units = self.units.sort(function(a,b) {
                  return a.break_count < b.break_count;
                });
            });
          },

          configure_date_range_picker: function() {
            var self = this;
            self.min_date = self.items.dates[0];
            self.max_date = self.items.dates[self.items.dates.length - 1];

            // Configure the date range input with the min and max dates
            var $el = $('#daterangeinput');
            var min_date_str = moment(self.min_date).format("MM/DD/YY");
            var max_date_str = moment(self.max_date).format("MM/DD/YY")
            $el.daterangepicker({
              "startDate" : min_date_str,
              "endDate" : max_date_str,  
              "minDate": min_date_str, 
              "maxDate": max_date_str
            });
            self.daterangeinput_el = $el;
            $el.on('apply.daterangepicker hide.daterangepicker', function(ev, picker) {
              self.updateDateRange()
            });
            self.updateDateRange();
          },

          updateDateRange: function() {

            if(this.daterangeinput_el === null) return;

            var d = this.daterangeinput_el.data('daterangepicker');
            if(d === null) return;

            this.start_date = d.startDate;
            this.end_date = d.endDate;

            this.start_date_index = this.start_date.diff(this.min_date, "days");
            this.end_date_index = this.end_date.diff(this.min_date, "days");

            var max_date_index = this.items.dates.length;
            if(this.start_date_index < 0 || this.start_date_index >= max_date_index) {
              console.log("Bad start date index: " + this.start_date_index + '. Max allowed is ' + max_date_index);
              this.start_date_index = 0;
            }           
            if(this.end_date_index < 0 || this.end_date_index >= max_date_index) {
              console.log("Bad end date index: " + this.end_date_index + '. Max allowed is ' + max_date_index);
              this.end_date_index = 0;
            }
            this.date_index = this.start_date_index;

          },

          next_tick: function() {

            var self = this;
            self.timeout_id = null;
            var this_tick, tick_delta, sleep;
            if(this.date_index < this.end_date_index) {
              self.animation_state = "PLAY";

              this_tick = new Date();
              tick_delta = this_tick - self.last_tick
              sleep = self.tick - tick_delta;
              if (sleep < 0) {
                console.log("Warning: Animation is lagging behind by " + sleep + " ms");
              }
              sleep = sleep > 0 ? sleep : 0;
              self.last_tick = this_tick;

              this.date_index += 1;
              self.timeout_id = setTimeout(function(){
                self.next_tick();
              }, sleep);

            } else {
              self.animation_state = "STOP";
            }

          },

          play: function() {

            if(this.animation_state === "PLAY") {
              return;
            }
            if( this.timeout_id != null) {
              return;
            }

            this.animation_state = "PLAY";
            this.next_tick();

          },

          stop: function() {
            this.animation_state = "STOP";
            if (this.timeout_id !== null) {
              window.clearTimeout(this.timeout_id);
              this.timeout_id = null;
            }
          },

          reset: function() {
            this.stop();
            this.date_index = this.start_date_index;

          },

          sort_units : function() {
            var self = this;
            if(this.sortorder == "unitid") {

              self.units = self.units.sort(function(left, right) {
                return left.unit_id < right.unit_id ? -1 : 1;
              });

            } else if (this.sortorder == "mostbroken") {

              self.units = self.units.sort(function(left, right) {
                return -(left.break_count - right.break_count);
              });
            } else if (this.sortorder == "station") {
              self.units = self.units.sort(function(left, right) {
                return left.station_name < right.station_name ? -1 : 1;
              });
            }

          }

        },

        computed: {
          num_units : function() {

            if(this.items === null) {
              return 0;
            }

            return this.items.units.length;

          }, 
          highlighted_units: function() {

            if(this.items === null) {
              return [];
            }

            var ones = this.items.category_by_date[this.status][this.date_index];
            if (ones === undefined) {
              return [];
            }
            var ret = Array(this.num_units).fill(0);
            ones.forEach(function(ind) {
              ret[ind] = 1;
            });
            return ret;
          }

        }

      });


      // $(function() {
      //   var $el = $('#daterangeinput');
      //   $el.daterangepicker();
      //   app.daterangeinput_el = $el;
      //   $el.on('apply.daterangepicker', function(ev, picker) {
      //     app.updateDateRange()
      //   });
      //   app.updateDateRange();
      // });




    </script>

  </body>

</html>